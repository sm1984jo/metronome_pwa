<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <title>메트로놈</title>
  <style>
    :root{--bg:#0f1218;--card:#151a22;--fg:#e8eef9;--sub:#9fb0c7;--accent:#66d9ef}
    *{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 70% -10%,#1a2230,transparent),var(--bg);color:var(--fg)}
    .wrap{max-width:840px;margin:24px auto;padding:24px;padding-bottom:calc(env(safe-area-inset-bottom) + 24px)}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:16px}
    h1{font-size:22px;margin:0;font-weight:700}
    .card{background:var(--card);border:1px solid #232a36;border-radius:14px;padding:18px}
    .controls{display:grid;grid-template-columns:1fr;gap:14px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .btn{appearance:none;border:0;border-radius:12px;padding:12px 16px;background:#1f2a3a;color:var(--fg);font-weight:700;cursor:pointer;transition:.15s;box-shadow:0 0 0 1px #2a3445 inset}
    .btn.good{background:#1f3a2a;box-shadow:0 0 0 1px #2e5f46 inset}
    .btn.warn{background:#3a2d1f;box-shadow:0 0 0 1px #6a4e2b inset}
    .btn.ghost{background:#1a2130}
    .big{font-size:34px;line-height:1;font-variant-numeric:tabular-nums}
    .sub{color:var(--sub);font-size:12px}
    input[type="range"]{width:100%}
    .display{display:flex;align-items:center;justify-content:center;height:160px;margin:14px 0;border-radius:14px;border:1px solid #2a3445;background:linear-gradient(180deg,#162030,#101520)}
    .leds{display:flex;justify-content:center;gap:10px;margin-top:10px}
    .led{width:12px;height:12px;border-radius:50%;background:#2a3445;transition:.06s}
    .led.on{background:var(--accent);box-shadow:0 0 18px var(--accent)}
    .overlay{position:fixed;inset:0;background:rgba(0,0,0,.65);display:flex;align-items:center;justify-content:center;z-index:9999}
    .sheet{background:#101725;border:1px solid #2a3445;border-radius:16px;padding:22px;max-width:420px;margin:20px;text-align:center}
    .sheet h2{margin:0 0 10px 0}
    .sheet p{margin:0 0 14px 0;color:var(--sub)}
    .sheet .btn{width:100%;font-size:18px}
    .version{margin:40px 0 12px;text-align:center;color:var(--sub);font-size:11px;opacity:.7}
  </style>
</head>
<body>
  <div class="overlay" id="unlockOverlay">
    <div class="sheet">
      <h2>소리 활성화</h2>
      <p>iPhone 정책 때문에 먼저 한 번 눌러주세요.</p>
      <button class="btn" id="unlockBtn">소리 켜기</button>
    </div>
  </div>

  <div class="wrap">
    <header>
      <h1>메트로놈</h1>
      <div class="sub">홈 화면에 추가 → 앱처럼 사용 · 오프라인</div>
    </header>

    <div class="card">
      <div class="controls">
        <div>
          <label for="bpm">BPM</label>
          <div class="row">
            <button class="btn ghost" id="minus10">-10</button>
            <input id="bpm" type="range" min="20" max="300" value="100" step="1" />
            <button class="btn ghost" id="plus10">+10</button>
          </div>
          <div class="row">
            <div class="big" id="bpmDisplay">100</div>
            <button class="btn" id="tapBtn">탭 템포</button>
            <button class="btn" id="nudgeDown">-</button>
            <button class="btn" id="nudgeUp">+</button>
          </div>
          <div class="row sub" id="tapInfo">T 키 또는 버튼을 3–6번 탭하세요.</div>
        </div>

        <div>
          <label>박자/악센트</label>
          <div class="row">
            <select id="beats" class="btn ghost">
              <option value="2">2/4</option>
              <option value="3">3/4</option>
              <option value="4" selected>4/4</option>
              <option value="5">5/4</option>
              <option value="6">6/8</option>
              <option value="7">7/8</option>
              <option value="9">9/8</option>
            </select>
            <select id="subdiv" class="btn ghost">
              <option value="1" selected>분할 없음</option>
              <option value="2">2분할</option>
              <option value="3">3분할</option>
              <option value="4">4분할</option>
            </select>
          </div>
          <div class="row">
            <label class="sub"><input type="checkbox" id="accentFirst" checked /> 첫 박자 악센트</label>
            <label class="sub"><input type="checkbox" id="swing" /> 스윙(재즈)</label>
          </div>
          <div class="row">
            <button class="btn good" id="startStop">시작</button>
            <button class="btn warn" id="reset">리셋</button>
          </div>
        </div>

        <div>
          <label>소리/표시</label>
          <div class="row">
            <select id="sound" class="btn ghost">
              <option value="click" selected>클릭</option>
              <option value="wood">우드블록</option>
              <option value="beep">비프</option>
            </select>
            <input id="volume" type="range" min="0" max="1" step="0.01" value="0.9" />
          </div>
          <div class="row">
            <label class="sub"><input type="checkbox" id="visual" checked /> 화면 플래시</label>
          </div>
        </div>
      </div>

      <div class="display" id="display">
        <div class="big" id="beatText">1</div>
      </div>
      <div class="leds" id="leds"></div>
    </div>
  </div>

  <div class="version">버전 v1.0.3</div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}

(() => {
  const $ = s => document.querySelector(s);
  const unlockOverlay = $('#unlockOverlay');
  const unlockBtn = $('#unlockBtn');
  let audioCtx, unlocked = false;
  let currentSamples = null;
  let currentSampleType = null;
  let soundChoice = 'click';
  const sampleCache = new Map();
  const samplePromises = new Map();

  const SOUND_DEFS = {
    click: {
      accent: { freq: 2300, duration: 0.14, attack: 0.0018, decay: 0.11, partials: [1, 0.4, 0.18] },
      normal: { freq: 1800, duration: 0.12, attack: 0.002, decay: 0.1, partials: [1, 0.32, 0.12] },
      sub: { freq: 1400, duration: 0.1, attack: 0.0024, decay: 0.08, partials: [1, 0.25] }
    },
    wood: {
      accent: { freq: 1050, duration: 0.16, attack: 0.002, decay: 0.13, partials: [1, 0.5, 0.22], noise: 0.08 },
      normal: { freq: 820, duration: 0.14, attack: 0.0024, decay: 0.11, partials: [1, 0.35, 0.18], noise: 0.05 },
      sub: { freq: 620, duration: 0.12, attack: 0.003, decay: 0.09, partials: [1, 0.28], noise: 0.04 }
    },
    beep: {
      accent: { freq: 1200, duration: 0.18, attack: 0.003, decay: 0.14, partials: [1] },
      normal: { freq: 900, duration: 0.16, attack: 0.003, decay: 0.12, partials: [1] },
      sub: { freq: 720, duration: 0.14, attack: 0.004, decay: 0.1, partials: [1] }
    }
  };

  function writeString(view, offset, str){
    for(let i=0;i<str.length;i++){
      view.setUint8(offset+i, str.charCodeAt(i));
    }
  }

  function floatTo16BitPCM(view, offset, input){
    for(let i=0;i<input.length;i++, offset+=2){
      const s = Math.max(-1, Math.min(1, input[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
  }

  function createWavArrayBuffer({ sampleRate, freq, duration, attack, decay, partials, noise }){
    const length = Math.floor(duration * sampleRate);
    const data = new Float32Array(length);
    const attackSamples = Math.max(1, Math.floor(attack * sampleRate));
    const decayConst = Math.max(0.0001, decay);

    for(let i=0;i<length;i++){
      const t = i / sampleRate;
      const envAttack = Math.min(1, i / attackSamples);
      const envDecay = Math.exp(-t / decayConst);
      let sample = 0;
      partials.forEach((amp, idx)=>{
        sample += amp * Math.sin(2 * Math.PI * freq * (idx + 1) * t);
      });
      if(noise){
        sample += (Math.random() * 2 - 1) * noise;
      }
      data[i] = sample * envAttack * envDecay;
    }

    const bytesPerSample = 2;
    const dataLength = length * bytesPerSample;
    const buffer = new ArrayBuffer(44 + dataLength);
    const view = new DataView(buffer);

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataLength, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * bytesPerSample, true);
    view.setUint16(32, bytesPerSample, true);
    view.setUint16(34, 8 * bytesPerSample, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataLength, true);
    floatTo16BitPCM(view, 44, data);

    return buffer;
  }

  function decodeAudioBuffer(ctx, arrayBuffer){
    return new Promise((resolve, reject)=>{
      if(ctx.decodeAudioData.length === 1){
        ctx.decodeAudioData(arrayBuffer).then(resolve).catch(reject);
      } else {
        ctx.decodeAudioData(arrayBuffer, resolve, reject);
      }
    });
  }

  async function loadSampleSet(ctx, type){
    const defs = SOUND_DEFS[type];
    const entries = await Promise.all(Object.entries(defs).map(async ([key, opts])=>{
      const arrayBuffer = createWavArrayBuffer({
        sampleRate: ctx.sampleRate,
        freq: opts.freq,
        duration: opts.duration,
        attack: opts.attack,
        decay: opts.decay,
        partials: opts.partials,
        noise: opts.noise || 0
      });
      const decoded = await decodeAudioBuffer(ctx, arrayBuffer);
      return [key, decoded];
    }));
    return Object.fromEntries(entries);
  }

  async function ensureSamples(ctx, type){
    if(currentSampleType === type && currentSamples){
      return currentSamples;
    }
    if(sampleCache.has(type)){
      currentSamples = sampleCache.get(type);
      currentSampleType = type;
      return currentSamples;
    }
    if(samplePromises.has(type)){
      const cached = await samplePromises.get(type);
      currentSamples = cached;
      currentSampleType = type;
      return currentSamples;
    }
    const promise = loadSampleSet(ctx, type).then(set=>{
      sampleCache.set(type, set);
      samplePromises.delete(type);
      return set;
    });
    samplePromises.set(type, promise);
    const loaded = await promise;
    currentSamples = loaded;
    currentSampleType = type;
    return loaded;
  }

  function showOverlay(){
    unlockOverlay.style.display='flex';
  }

  function hideOverlay(){
    unlockOverlay.style.display='none';
  }

  function primeContext(ctx){
    try {
      const buffer = ctx.createBuffer(1,1,22050);
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.connect(ctx.destination);
      src.start(0);
    } catch(e){}
  }

  function handleStateChange(){
    if(!audioCtx) return;
    if(audioCtx.state === 'running'){
      if(!unlocked){
        primeContext(audioCtx);
        unlocked = true;
        ensureSamples(audioCtx, soundChoice);
      }
      hideOverlay();
    } else {
      unlocked = false;
      showOverlay();
    }
  }

  async function ensureAudioContext(){
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;
    if(!audioCtx){
      audioCtx = new Ctx();
      audioCtx.addEventListener('statechange', handleStateChange);
    }
    return audioCtx;
  }

  async function unlockAudio(){
    const ctx = await ensureAudioContext();
    if(!ctx) return null;
    if(ctx.state !== 'running'){
      try { await ctx.resume(); } catch(e){}
    }
    if(ctx.state !== 'running'){
      unlocked = false;
      showOverlay();
      return null;
    }
    if(!unlocked){
      primeContext(ctx);
      unlocked = true;
    }
    await ensureSamples(ctx, soundChoice);
    hideOverlay();
    return ctx;
  }
  ['touchstart','mousedown','keydown'].forEach(ev=>window.addEventListener(ev, ()=>{ if(!unlocked) unlockAudio(); }, {passive:true}));
  unlockBtn.addEventListener('click', unlockAudio);

  const bpmEl = $('#bpm'); const bpmDisplay = $('#bpmDisplay');
  const startStopBtn = $('#startStop'); const resetBtn = $('#reset');
  const tapBtn = $('#tapBtn'); const tapInfo = $('#tapInfo');
  const beatsEl = $('#beats'); const subdivEl = $('#subdiv');
  const accentFirstEl = $('#accentFirst'); const swingEl = $('#swing');
  const soundEl = $('#sound'); const volumeEl = $('#volume');
  soundChoice = soundEl.value;
  const visualEl = $('#visual'); const display = $('#display');
  const beatText = $('#beatText'); const leds = $('#leds');
  const minus10 = $('#minus10'); const plus10 = $('#plus10');
  const nudgeUp = $('#nudgeUp'); const nudgeDown = $('#nudgeDown');

  let isRunning=false, currentBeat=0, nextNoteTime=0, scheduleTimer;
  let tapTimes=[], lastTap=0;
  const lookahead=25, scheduleAheadTime=0.1;

  function updateBpmDisplay(){ bpmDisplay.textContent = bpmEl.value; }
  function noteLengthSec(){ const bpm=+bpmEl.value; const base=60/bpm; const subdiv=+subdivEl.value; if(swingEl.checked&&subdiv===2) return base/2; return subdiv>1? base/subdiv: base; }

  function scheduleClick(time, isAccent, isSub){
    if(!audioCtx || audioCtx.state !== 'running' || !currentSamples) return;
    const buffer = isAccent ? currentSamples.accent : (isSub ? currentSamples.sub : currentSamples.normal);
    if(!buffer) return;
    const gainNode = audioCtx.createGain();
    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    gainNode.gain.setValueAtTime(+volumeEl.value, time);
    src.connect(gainNode).connect(audioCtx.destination);
    src.start(time);
  }

  function flashVisual(ac){ if(!visualEl.checked) return; display.style.transform='scale(1.02)';
    display.style.boxShadow=ac?'0 0 40px rgba(102,217,239,.5)':'0 0 22px rgba(102,217,239,.25)';
    setTimeout(()=>{display.style.transform='scale(1)'; display.style.boxShadow='none';},60); }

  function updateLEDs(active,total){ leds.innerHTML=''; for(let i=0;i<total;i++){ const d=document.createElement('div'); d.className='led'+(i===active?' on':''); leds.appendChild(d);} }

  function scheduler(){
    if(!audioCtx || audioCtx.state !== 'running'){
      stop();
      return;
    }
    while(audioCtx && nextNoteTime < audioCtx.currentTime + scheduleAheadTime){
      const beatsPerBar=+beatsEl.value; const subdiv=+subdivEl.value;
      const beatIndex=currentBeat % beatsPerBar; 
      const isBarAccent=accentFirstEl.checked && beatIndex===0; 
      let stepsThisBeat=subdiv; if(subdiv===1) stepsThisBeat=1; 
      for(let s=0;s<stepsThisBeat;s++){ 
        const isSub=(s!==0); const isAccent=isBarAccent && s===0; 
        scheduleClick(nextNoteTime,isAccent,isSub); 
        if(s===0){ setTimeout(((accent,beatNo)=>()=>{ 
          beatText.textContent=(beatNo+1); updateLEDs(beatNo,beatsPerBar); flashVisual(accent); 
        })(isAccent,beatIndex), Math.max(0,(nextNoteTime - audioCtx.currentTime)*1000 - 8)); } 
        let stepLen=noteLengthSec(); if(swingEl.checked && subdiv===2){ stepLen = s===0 ? stepLen*2/3 : stepLen*1/3; } 
        nextNoteTime += stepLen; 
      } 
      currentBeat = (currentBeat + 1) % beatsPerBar; 
    } 
  }

  async function start(){
    const ctx = await unlockAudio();
    if(!ctx || ctx.state !== 'running') return;
    if(isRunning) return;
    await ensureSamples(ctx, soundChoice);
    if(!currentSamples) return;
    isRunning=true; startStopBtn.textContent='정지';
    const beatsPerBar=+beatsEl.value; updateLEDs(0,beatsPerBar);
    currentBeat=0; nextNoteTime = ctx.currentTime + 0.08;
    scheduler();
    scheduleTimer = setInterval(scheduler, lookahead);
  }

  function stop(){
    isRunning=false; startStopBtn.textContent='시작';
    if(scheduleTimer){
      clearInterval(scheduleTimer);
      scheduleTimer=null;
    }
  }
  function reset(){ stop(); tapTimes=[]; beatText.textContent='1'; updateLEDs(0, +beatsEl.value); }

  startStopBtn.addEventListener('click', ()=>{
    if(isRunning) stop();
    else start();
  });
  resetBtn.addEventListener('click', reset);
  bpmEl.addEventListener('input', updateBpmDisplay);
  minus10.addEventListener('click', ()=>{ bpmEl.value=Math.max(20, +bpmEl.value-10); updateBpmDisplay(); });
  plus10.addEventListener('click', ()=>{ bpmEl.value=Math.min(300, +bpmEl.value+10); updateBpmDisplay(); });
  nudgeUp.addEventListener('click', ()=>{ bpmEl.value=Math.min(300, +bpmEl.value+1); updateBpmDisplay(); });
  nudgeDown.addEventListener('click', ()=>{ bpmEl.value=Math.max(20, +bpmEl.value-1); updateBpmDisplay(); });

  // Tap tempo
  function onTap(){ const now=performance.now(); if(lastTap && (now-lastTap)>1500) tapTimes=[]; tapTimes.push(now); lastTap=now; 
    if(tapTimes.length>=3){ const ints=[]; for(let i=1;i<tapTimes.length;i++){ ints.push(tapTimes[i]-tapTimes[i-1]); } 
      ints.sort((a,b)=>a-b); let use=ints.slice(); if(ints.length>=4) use=ints.slice(1,-1); 
      const avg=use.reduce((a,b)=>a+b,0)/use.length; const bpm=Math.max(20, Math.min(300, Math.round(60000/avg))); 
      bpmEl.value=bpm; updateBpmDisplay(); tapInfo.textContent=`탭 기반 BPM ≈ ${bpm}`; } 
    else { tapInfo.textContent = `${tapTimes.length}회 탭됨…`; } }
  tapBtn.addEventListener('click', onTap);
  soundEl.addEventListener('change', async ()=>{
    soundChoice = soundEl.value;
    if(audioCtx){
      await ensureSamples(audioCtx, soundChoice);
    }
  });

  updateBpmDisplay(); updateLEDs(0, +beatsEl.value);
})();
</script>
</body>
</html>